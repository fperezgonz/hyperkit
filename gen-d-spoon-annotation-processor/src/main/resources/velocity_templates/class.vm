#set($lb="
")
#macro( indent $indentLevel $bodyContent)
    #foreach($bodyLine in $bodyContent.lines().toList())
##      Write indents
        #foreach($level in [1..$indentLevel])    #end
##          Write line
#*        *#$bodyLine#if(!${foreach.last})$lb#end##
    #end
#end
#macro(concatCollection $collection $separator)
    #foreach($element in $collection)#if(!${foreach.first})$separator#end$element#end
#end
package ${ctClass.package};

### Imports
#foreach($import in $imports)
    #set($importQualName = ${import.qualifiedName.toString()})
    #if ($importQualName != "long" && $importQualName != "int"
        && $importQualName != "boolean" && $importQualName != "short"
        && $importQualName != "float" && $importQualName != "double"
        && $importQualName != "byte" && $importQualName != "char"
        && !${importQualName.startsWith("java.lang")} )
import ${importQualName};
    #end
#end

### Class annotations
#set($annotations = $ctClass.annotations)
#foreach($annotation in $annotations)
${annotation}
#end
### Class
class ${ctClass.simpleName} implements #concatCollection($ctClass.superInterfaces, ", "){

#foreach($field in ${ctClass.fields})
    ##
    #concatCollection($field.modifiers, " ") ${field.type} ${field.simpleName} = Option.none();$lb##
#end

#foreach($constructor in ${ctClass.constructors})
    #indent(1, ${constructor.toString()})$lb##
#end

#foreach($method in ${ctClass.methods})
    #indent(1, ${method.toString()})$lb##
#end

### Builder class
#foreach($type in ${ctClass.nestedTypes})
    #if($type.simpleName=="Builder")
    ##
        #concatCollection($type.modifiers, " ") class Builder{

        #foreach($field in ${ctClass.fields})
            #indent(2, ${field.type.toString()}) ${field.simpleName} = Option.none();$lb##
        #end

        public Builder(){}

        public static  Builder newInstance(){
            return new Builder();
        }

##      Builder methods
        #foreach($field in ${ctClass.fields})
        public Builder ${field.simpleName}(final ${field.type} ${field.simpleName})}{
            this.${field.simpleName} = ${field.simpleName} == null ? Option.none() : ${field.simpleName};
            return this;
        }

        #end

        public ${ctClass.simpleName} build(){

            ${ctClass.simpleName} instance = new ${ctClass.simpleName}();
        #foreach($field in ${ctClass.fields})
            instance.${field.simpleName} = ${field.simpleName};
        #end

            return instance;

        }

    }
    #end
#end

### Projection class
#foreach($type in ${ctClass.nestedTypes})
    #if($type.simpleName=="Projection")
        #set($annotations = $type.annotations)
        #foreach($annotation in $annotations)
            #indent(1, ${annotation.toString()})$lb##
        #end
    ##
        #concatCollection($type.modifiers, " ") class Projection extends ${type.superclass.simpleName}<${ctClass.simpleName}>{

        #foreach($field in ${ctClass.fields})
            #if(${field.type.actualTypeArguments.get(0).qualifiedName} == "java.util.List"
            || ${field.type.actualTypeArguments.get(0).qualifiedName} == "java.util.Set")
                #indent(2, "public ListFieldConf") ${field.simpleName};
            #else
                #indent(2, "public FieldConf") ${field.simpleName};
            #end
        #end

        public void applyProjectionTo(${ctClass.simpleName} dto) throws DtoProjectionException {
        #foreach($field in ${ctClass.fields})
            dto.${field.simpleName} = ProjectionUtils.getProjectedValue(dto.${field.simpleName}, this.${field.simpleName});
        #end
        }

    }
    #end
#end

### DtoModel class
#foreach($type in ${ctClass.nestedTypes})
    #if($type.simpleName=="DtoModel")
    ##
    #concatCollection($type.modifiers, " ") class DtoModel{

    #foreach($field in ${ctClass.fields})
        public static final String _${field.simpleName} = "${field.simpleName}";
    #end

    }
    #end
#end

}