import java.math.BigDecimal;
import java.util.ArrayList;
import java.util.List;

@DtoConfFor(ExampleDto.class)
public class ExampleDtoConf<ExampleDto> {
    @Nullable
    DtoFieldConf<Option<Long>> exampleId;
    @Nullable
    DtoFieldConf<String> exampleName;
    @Nullable
    DtoFieldConf<Instant> exampleTimestamp;
    @Nullable
    DtoFieldConf<BigDecimal> exampleBDecimal;
    @Nullable
    DtoListConf<Entity> exampleEntityList;
    @Nullable
    ValidationConf<ExampleDto> validation;
}

public class DtoFieldConf<T /* Field type */> {
    @Nullable
    ValidationConf<T> validation;
    // TODO can throw exceptions
    @Nullable
    Function<IT /* Input type */, T> pipeIn;
    @Nullable
    Function<T, OT/* Output type */> pipeOut;
}

public class CollectionOperationType<T> {
    public T value;

    public static enum Type {
        INSERT, UPDATE, UPSERT, DELETE
    };
}

public class DtoListConf<T /* List entity type */> {
    boolean presenceRequired = false;
    boolean allowInsert = false;
    boolean allowUpdate = false;
    boolean allowDelete = false;
    @Nullable
    ValidationConf<List<CollectionOperationType<T>>> validation;
}

public class ValidationError {
    String errorCode;
    String messageTemplate;
}

public static class ValidationResponse<T> {
    ResponseType responseType;
    /* NonNull if responseType==ResponseType.ERROR, null otherwise */
    ValidationError validationError;
    // e.g.: warnings, tips, extra data
    Map<String, ?> extensions;

    public static enum ResponseType {
        VALID, ERROR
    }

}

public class ValidationConf<T> {
    List<ValidationFunction<T>> defaultValidationChain;
    List<List<ValidationFunction<T>>> validationChains;

    public ValidationConf<T> add(ValidationFunction<T> validationFunction) {

        defaultValidationChain.add(validationFunction);

        return this;

    }

    public ValidationConf<T> chain(ValidationFunction<T>... validationFunctions) {

        List<ValidationFunction<T>> newValidationChain = new ArrayList<>();

        for (ValidationFunction<T> validationFunction : validationFunctions) {
            newValidationChain.add(validationFunction);
        }

        validationChains.add(newValidationChain);

        return this;

    }

    List<ValidationResponse> validate(T entityDto){
        //TODO
    }

}

public interface ValidationFunction<T> extends Function<T, ValidationError> {
}

public class Validations {

    /**
     * This is the only validation that is applicable to a field when there is no
     * value present
     */
    public static final ValidationFunction<?> PRESENCE_REQUIRED;
    /**
     * The following validations are only executed if there is a value present (even
     * if the value is null)
     */
    public static final ValidationFunction<?> NON_NULL = (value) -> Objects.requireNonNullElseGet(value,
            ValidationErrors.NON_NULL);
    public static final ValidationFunction<String> STRING_NOT_EMPTY;
    public static final ValidationFunction<Number> IS_POSITIVE;
    public static final ValidationFunction<Number> IS_NEGATIVE;
    public static final ValidationFunction<Number> NOT_ZERO;

    public static ValidationFunction<String> minLength(int minLength, @Nullable ValidationError validationFailedError) {
        return;
    }

    public static ValidationFunction<String> maxLength(int maxLength, @Nullable ValidationError validationFailedError) {
        return;
    }

    public static <Number> ValidationFunction<Number> minValue(double minValue,
            @Nullable ValidationError validationFailedError) {
        return;
    }

    public static <Number> ValidationFunction<Number> maxValue(double maxValue,
            @Nullable ValidationError validationFailedError) {
        return;
    }

}